// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages_parsian_worldmodel.proto

#ifndef PROTOBUF_messages_5fparsian_5fworldmodel_2eproto__INCLUDED
#define PROTOBUF_messages_5fparsian_5fworldmodel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messages_5fparsian_5fworldmodel_2eproto();
void protobuf_AssignDesc_messages_5fparsian_5fworldmodel_2eproto();
void protobuf_ShutdownFile_messages_5fparsian_5fworldmodel_2eproto();

class Vector2DProto;
class MovingObjectProto;
class WorldModelProto;

enum GameStateProto {
  PlayOn = 0,
  FreeBall_LeftTop = 1,
  FreeBall_LeftBot = 2,
  FreeBall_RightTop = 3,
  FreeBall_RightBot = 4,
  PlaceKick_Yellow = 5,
  PlaceKick_Blue = 6,
  PenaltyKick_Yellow = 7,
  PenaltyKick_Blue = 8,
  FreeKick_Yellow = 9,
  FreeKick_Blue = 10,
  GoalKick_Yellow = 11,
  GoalKick_Blue = 12
};
bool GameStateProto_IsValid(int value);
const GameStateProto GameStateProto_MIN = PlayOn;
const GameStateProto GameStateProto_MAX = GoalKick_Blue;
const int GameStateProto_ARRAYSIZE = GameStateProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameStateProto_descriptor();
inline const ::std::string& GameStateProto_Name(GameStateProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameStateProto_descriptor(), value);
}
inline bool GameStateProto_Parse(
    const ::std::string& name, GameStateProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameStateProto>(
    GameStateProto_descriptor(), name, value);
}
// ===================================================================

class Vector2DProto : public ::google::protobuf::Message {
 public:
  Vector2DProto();
  virtual ~Vector2DProto();

  Vector2DProto(const Vector2DProto& from);

  inline Vector2DProto& operator=(const Vector2DProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector2DProto& default_instance();

  void Swap(Vector2DProto* other);

  // implements Message ----------------------------------------------

  Vector2DProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector2DProto& from);
  void MergeFrom(const Vector2DProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:Vector2DProto)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  friend void  protobuf_AddDesc_messages_5fparsian_5fworldmodel_2eproto();
  friend void protobuf_AssignDesc_messages_5fparsian_5fworldmodel_2eproto();
  friend void protobuf_ShutdownFile_messages_5fparsian_5fworldmodel_2eproto();

  void InitAsDefaultInstance();
  static Vector2DProto* default_instance_;
};
// -------------------------------------------------------------------

class MovingObjectProto : public ::google::protobuf::Message {
 public:
  MovingObjectProto();
  virtual ~MovingObjectProto();

  MovingObjectProto(const MovingObjectProto& from);

  inline MovingObjectProto& operator=(const MovingObjectProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MovingObjectProto& default_instance();

  void Swap(MovingObjectProto* other);

  // implements Message ----------------------------------------------

  MovingObjectProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MovingObjectProto& from);
  void MergeFrom(const MovingObjectProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required .Vector2DProto pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline const ::Vector2DProto& pos() const;
  inline ::Vector2DProto* mutable_pos();
  inline ::Vector2DProto* release_pos();
  inline void set_allocated_pos(::Vector2DProto* pos);

  // required .Vector2DProto vel = 3;
  inline bool has_vel() const;
  inline void clear_vel();
  static const int kVelFieldNumber = 3;
  inline const ::Vector2DProto& vel() const;
  inline ::Vector2DProto* mutable_vel();
  inline ::Vector2DProto* release_vel();
  inline void set_allocated_vel(::Vector2DProto* vel);

  // required .Vector2DProto acc = 4;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 4;
  inline const ::Vector2DProto& acc() const;
  inline ::Vector2DProto* mutable_acc();
  inline ::Vector2DProto* release_acc();
  inline void set_allocated_acc(::Vector2DProto* acc);

  // required float anguleVelocity = 5;
  inline bool has_angulevelocity() const;
  inline void clear_angulevelocity();
  static const int kAnguleVelocityFieldNumber = 5;
  inline float angulevelocity() const;
  inline void set_angulevelocity(float value);

  // required float direction = 6;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 6;
  inline float direction() const;
  inline void set_direction(float value);

  // @@protoc_insertion_point(class_scope:MovingObjectProto)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_vel();
  inline void clear_has_vel();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_angulevelocity();
  inline void clear_has_angulevelocity();
  inline void set_has_direction();
  inline void clear_has_direction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Vector2DProto* pos_;
  ::Vector2DProto* vel_;
  ::google::protobuf::uint32 id_;
  float angulevelocity_;
  ::Vector2DProto* acc_;
  float direction_;
  friend void  protobuf_AddDesc_messages_5fparsian_5fworldmodel_2eproto();
  friend void protobuf_AssignDesc_messages_5fparsian_5fworldmodel_2eproto();
  friend void protobuf_ShutdownFile_messages_5fparsian_5fworldmodel_2eproto();

  void InitAsDefaultInstance();
  static MovingObjectProto* default_instance_;
};
// -------------------------------------------------------------------

class WorldModelProto : public ::google::protobuf::Message {
 public:
  WorldModelProto();
  virtual ~WorldModelProto();

  WorldModelProto(const WorldModelProto& from);

  inline WorldModelProto& operator=(const WorldModelProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorldModelProto& default_instance();

  void Swap(WorldModelProto* other);

  // implements Message ----------------------------------------------

  WorldModelProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorldModelProto& from);
  void MergeFrom(const WorldModelProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MovingObjectProto ball = 1;
  inline bool has_ball() const;
  inline void clear_ball();
  static const int kBallFieldNumber = 1;
  inline const ::MovingObjectProto& ball() const;
  inline ::MovingObjectProto* mutable_ball();
  inline ::MovingObjectProto* release_ball();
  inline void set_allocated_ball(::MovingObjectProto* ball);

  // repeated .MovingObjectProto our_robots = 2;
  inline int our_robots_size() const;
  inline void clear_our_robots();
  static const int kOurRobotsFieldNumber = 2;
  inline const ::MovingObjectProto& our_robots(int index) const;
  inline ::MovingObjectProto* mutable_our_robots(int index);
  inline ::MovingObjectProto* add_our_robots();
  inline const ::google::protobuf::RepeatedPtrField< ::MovingObjectProto >&
      our_robots() const;
  inline ::google::protobuf::RepeatedPtrField< ::MovingObjectProto >*
      mutable_our_robots();

  // repeated .MovingObjectProto opp_robots = 3;
  inline int opp_robots_size() const;
  inline void clear_opp_robots();
  static const int kOppRobotsFieldNumber = 3;
  inline const ::MovingObjectProto& opp_robots(int index) const;
  inline ::MovingObjectProto* mutable_opp_robots(int index);
  inline ::MovingObjectProto* add_opp_robots();
  inline const ::google::protobuf::RepeatedPtrField< ::MovingObjectProto >&
      opp_robots() const;
  inline ::google::protobuf::RepeatedPtrField< ::MovingObjectProto >*
      mutable_opp_robots();

  // required bool blue = 4;
  inline bool has_blue() const;
  inline void clear_blue();
  static const int kBlueFieldNumber = 4;
  inline bool blue() const;
  inline void set_blue(bool value);

  // required string mode = 5;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 5;
  inline const ::std::string& mode() const;
  inline void set_mode(const ::std::string& value);
  inline void set_mode(const char* value);
  inline void set_mode(const char* value, size_t size);
  inline ::std::string* mutable_mode();
  inline ::std::string* release_mode();
  inline void set_allocated_mode(::std::string* mode);

  // required .GameStateProto gameState = 6;
  inline bool has_gamestate() const;
  inline void clear_gamestate();
  static const int kGameStateFieldNumber = 6;
  inline ::GameStateProto gamestate() const;
  inline void set_gamestate(::GameStateProto value);

  // @@protoc_insertion_point(class_scope:WorldModelProto)
 private:
  inline void set_has_ball();
  inline void clear_has_ball();
  inline void set_has_blue();
  inline void clear_has_blue();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_gamestate();
  inline void clear_has_gamestate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::MovingObjectProto* ball_;
  ::google::protobuf::RepeatedPtrField< ::MovingObjectProto > our_robots_;
  ::google::protobuf::RepeatedPtrField< ::MovingObjectProto > opp_robots_;
  ::std::string* mode_;
  bool blue_;
  int gamestate_;
  friend void  protobuf_AddDesc_messages_5fparsian_5fworldmodel_2eproto();
  friend void protobuf_AssignDesc_messages_5fparsian_5fworldmodel_2eproto();
  friend void protobuf_ShutdownFile_messages_5fparsian_5fworldmodel_2eproto();

  void InitAsDefaultInstance();
  static WorldModelProto* default_instance_;
};
// ===================================================================


// ===================================================================

// Vector2DProto

// required float x = 1;
inline bool Vector2DProto::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector2DProto::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector2DProto::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector2DProto::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector2DProto::x() const {
  // @@protoc_insertion_point(field_get:Vector2DProto.x)
  return x_;
}
inline void Vector2DProto::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Vector2DProto.x)
}

// required float y = 2;
inline bool Vector2DProto::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector2DProto::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector2DProto::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector2DProto::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector2DProto::y() const {
  // @@protoc_insertion_point(field_get:Vector2DProto.y)
  return y_;
}
inline void Vector2DProto::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Vector2DProto.y)
}

// -------------------------------------------------------------------

// MovingObjectProto

// required uint32 id = 1;
inline bool MovingObjectProto::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MovingObjectProto::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MovingObjectProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MovingObjectProto::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MovingObjectProto::id() const {
  // @@protoc_insertion_point(field_get:MovingObjectProto.id)
  return id_;
}
inline void MovingObjectProto::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:MovingObjectProto.id)
}

// required .Vector2DProto pos = 2;
inline bool MovingObjectProto::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MovingObjectProto::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MovingObjectProto::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MovingObjectProto::clear_pos() {
  if (pos_ != NULL) pos_->::Vector2DProto::Clear();
  clear_has_pos();
}
inline const ::Vector2DProto& MovingObjectProto::pos() const {
  // @@protoc_insertion_point(field_get:MovingObjectProto.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::Vector2DProto* MovingObjectProto::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::Vector2DProto;
  // @@protoc_insertion_point(field_mutable:MovingObjectProto.pos)
  return pos_;
}
inline ::Vector2DProto* MovingObjectProto::release_pos() {
  clear_has_pos();
  ::Vector2DProto* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void MovingObjectProto::set_allocated_pos(::Vector2DProto* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:MovingObjectProto.pos)
}

// required .Vector2DProto vel = 3;
inline bool MovingObjectProto::has_vel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MovingObjectProto::set_has_vel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MovingObjectProto::clear_has_vel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MovingObjectProto::clear_vel() {
  if (vel_ != NULL) vel_->::Vector2DProto::Clear();
  clear_has_vel();
}
inline const ::Vector2DProto& MovingObjectProto::vel() const {
  // @@protoc_insertion_point(field_get:MovingObjectProto.vel)
  return vel_ != NULL ? *vel_ : *default_instance_->vel_;
}
inline ::Vector2DProto* MovingObjectProto::mutable_vel() {
  set_has_vel();
  if (vel_ == NULL) vel_ = new ::Vector2DProto;
  // @@protoc_insertion_point(field_mutable:MovingObjectProto.vel)
  return vel_;
}
inline ::Vector2DProto* MovingObjectProto::release_vel() {
  clear_has_vel();
  ::Vector2DProto* temp = vel_;
  vel_ = NULL;
  return temp;
}
inline void MovingObjectProto::set_allocated_vel(::Vector2DProto* vel) {
  delete vel_;
  vel_ = vel;
  if (vel) {
    set_has_vel();
  } else {
    clear_has_vel();
  }
  // @@protoc_insertion_point(field_set_allocated:MovingObjectProto.vel)
}

// required .Vector2DProto acc = 4;
inline bool MovingObjectProto::has_acc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MovingObjectProto::set_has_acc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MovingObjectProto::clear_has_acc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MovingObjectProto::clear_acc() {
  if (acc_ != NULL) acc_->::Vector2DProto::Clear();
  clear_has_acc();
}
inline const ::Vector2DProto& MovingObjectProto::acc() const {
  // @@protoc_insertion_point(field_get:MovingObjectProto.acc)
  return acc_ != NULL ? *acc_ : *default_instance_->acc_;
}
inline ::Vector2DProto* MovingObjectProto::mutable_acc() {
  set_has_acc();
  if (acc_ == NULL) acc_ = new ::Vector2DProto;
  // @@protoc_insertion_point(field_mutable:MovingObjectProto.acc)
  return acc_;
}
inline ::Vector2DProto* MovingObjectProto::release_acc() {
  clear_has_acc();
  ::Vector2DProto* temp = acc_;
  acc_ = NULL;
  return temp;
}
inline void MovingObjectProto::set_allocated_acc(::Vector2DProto* acc) {
  delete acc_;
  acc_ = acc;
  if (acc) {
    set_has_acc();
  } else {
    clear_has_acc();
  }
  // @@protoc_insertion_point(field_set_allocated:MovingObjectProto.acc)
}

// required float anguleVelocity = 5;
inline bool MovingObjectProto::has_angulevelocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MovingObjectProto::set_has_angulevelocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MovingObjectProto::clear_has_angulevelocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MovingObjectProto::clear_angulevelocity() {
  angulevelocity_ = 0;
  clear_has_angulevelocity();
}
inline float MovingObjectProto::angulevelocity() const {
  // @@protoc_insertion_point(field_get:MovingObjectProto.anguleVelocity)
  return angulevelocity_;
}
inline void MovingObjectProto::set_angulevelocity(float value) {
  set_has_angulevelocity();
  angulevelocity_ = value;
  // @@protoc_insertion_point(field_set:MovingObjectProto.anguleVelocity)
}

// required float direction = 6;
inline bool MovingObjectProto::has_direction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MovingObjectProto::set_has_direction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MovingObjectProto::clear_has_direction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MovingObjectProto::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline float MovingObjectProto::direction() const {
  // @@protoc_insertion_point(field_get:MovingObjectProto.direction)
  return direction_;
}
inline void MovingObjectProto::set_direction(float value) {
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:MovingObjectProto.direction)
}

// -------------------------------------------------------------------

// WorldModelProto

// required .MovingObjectProto ball = 1;
inline bool WorldModelProto::has_ball() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorldModelProto::set_has_ball() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorldModelProto::clear_has_ball() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorldModelProto::clear_ball() {
  if (ball_ != NULL) ball_->::MovingObjectProto::Clear();
  clear_has_ball();
}
inline const ::MovingObjectProto& WorldModelProto::ball() const {
  // @@protoc_insertion_point(field_get:WorldModelProto.ball)
  return ball_ != NULL ? *ball_ : *default_instance_->ball_;
}
inline ::MovingObjectProto* WorldModelProto::mutable_ball() {
  set_has_ball();
  if (ball_ == NULL) ball_ = new ::MovingObjectProto;
  // @@protoc_insertion_point(field_mutable:WorldModelProto.ball)
  return ball_;
}
inline ::MovingObjectProto* WorldModelProto::release_ball() {
  clear_has_ball();
  ::MovingObjectProto* temp = ball_;
  ball_ = NULL;
  return temp;
}
inline void WorldModelProto::set_allocated_ball(::MovingObjectProto* ball) {
  delete ball_;
  ball_ = ball;
  if (ball) {
    set_has_ball();
  } else {
    clear_has_ball();
  }
  // @@protoc_insertion_point(field_set_allocated:WorldModelProto.ball)
}

// repeated .MovingObjectProto our_robots = 2;
inline int WorldModelProto::our_robots_size() const {
  return our_robots_.size();
}
inline void WorldModelProto::clear_our_robots() {
  our_robots_.Clear();
}
inline const ::MovingObjectProto& WorldModelProto::our_robots(int index) const {
  // @@protoc_insertion_point(field_get:WorldModelProto.our_robots)
  return our_robots_.Get(index);
}
inline ::MovingObjectProto* WorldModelProto::mutable_our_robots(int index) {
  // @@protoc_insertion_point(field_mutable:WorldModelProto.our_robots)
  return our_robots_.Mutable(index);
}
inline ::MovingObjectProto* WorldModelProto::add_our_robots() {
  // @@protoc_insertion_point(field_add:WorldModelProto.our_robots)
  return our_robots_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MovingObjectProto >&
WorldModelProto::our_robots() const {
  // @@protoc_insertion_point(field_list:WorldModelProto.our_robots)
  return our_robots_;
}
inline ::google::protobuf::RepeatedPtrField< ::MovingObjectProto >*
WorldModelProto::mutable_our_robots() {
  // @@protoc_insertion_point(field_mutable_list:WorldModelProto.our_robots)
  return &our_robots_;
}

// repeated .MovingObjectProto opp_robots = 3;
inline int WorldModelProto::opp_robots_size() const {
  return opp_robots_.size();
}
inline void WorldModelProto::clear_opp_robots() {
  opp_robots_.Clear();
}
inline const ::MovingObjectProto& WorldModelProto::opp_robots(int index) const {
  // @@protoc_insertion_point(field_get:WorldModelProto.opp_robots)
  return opp_robots_.Get(index);
}
inline ::MovingObjectProto* WorldModelProto::mutable_opp_robots(int index) {
  // @@protoc_insertion_point(field_mutable:WorldModelProto.opp_robots)
  return opp_robots_.Mutable(index);
}
inline ::MovingObjectProto* WorldModelProto::add_opp_robots() {
  // @@protoc_insertion_point(field_add:WorldModelProto.opp_robots)
  return opp_robots_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MovingObjectProto >&
WorldModelProto::opp_robots() const {
  // @@protoc_insertion_point(field_list:WorldModelProto.opp_robots)
  return opp_robots_;
}
inline ::google::protobuf::RepeatedPtrField< ::MovingObjectProto >*
WorldModelProto::mutable_opp_robots() {
  // @@protoc_insertion_point(field_mutable_list:WorldModelProto.opp_robots)
  return &opp_robots_;
}

// required bool blue = 4;
inline bool WorldModelProto::has_blue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WorldModelProto::set_has_blue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WorldModelProto::clear_has_blue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WorldModelProto::clear_blue() {
  blue_ = false;
  clear_has_blue();
}
inline bool WorldModelProto::blue() const {
  // @@protoc_insertion_point(field_get:WorldModelProto.blue)
  return blue_;
}
inline void WorldModelProto::set_blue(bool value) {
  set_has_blue();
  blue_ = value;
  // @@protoc_insertion_point(field_set:WorldModelProto.blue)
}

// required string mode = 5;
inline bool WorldModelProto::has_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WorldModelProto::set_has_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WorldModelProto::clear_has_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WorldModelProto::clear_mode() {
  if (mode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mode_->clear();
  }
  clear_has_mode();
}
inline const ::std::string& WorldModelProto::mode() const {
  // @@protoc_insertion_point(field_get:WorldModelProto.mode)
  return *mode_;
}
inline void WorldModelProto::set_mode(const ::std::string& value) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mode_ = new ::std::string;
  }
  mode_->assign(value);
  // @@protoc_insertion_point(field_set:WorldModelProto.mode)
}
inline void WorldModelProto::set_mode(const char* value) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mode_ = new ::std::string;
  }
  mode_->assign(value);
  // @@protoc_insertion_point(field_set_char:WorldModelProto.mode)
}
inline void WorldModelProto::set_mode(const char* value, size_t size) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mode_ = new ::std::string;
  }
  mode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:WorldModelProto.mode)
}
inline ::std::string* WorldModelProto::mutable_mode() {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:WorldModelProto.mode)
  return mode_;
}
inline ::std::string* WorldModelProto::release_mode() {
  clear_has_mode();
  if (mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mode_;
    mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WorldModelProto::set_allocated_mode(::std::string* mode) {
  if (mode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mode_;
  }
  if (mode) {
    set_has_mode();
    mode_ = mode;
  } else {
    clear_has_mode();
    mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:WorldModelProto.mode)
}

// required .GameStateProto gameState = 6;
inline bool WorldModelProto::has_gamestate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WorldModelProto::set_has_gamestate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WorldModelProto::clear_has_gamestate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WorldModelProto::clear_gamestate() {
  gamestate_ = 0;
  clear_has_gamestate();
}
inline ::GameStateProto WorldModelProto::gamestate() const {
  // @@protoc_insertion_point(field_get:WorldModelProto.gameState)
  return static_cast< ::GameStateProto >(gamestate_);
}
inline void WorldModelProto::set_gamestate(::GameStateProto value) {
  assert(::GameStateProto_IsValid(value));
  set_has_gamestate();
  gamestate_ = value;
  // @@protoc_insertion_point(field_set:WorldModelProto.gameState)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::GameStateProto> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GameStateProto>() {
  return ::GameStateProto_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_5fparsian_5fworldmodel_2eproto__INCLUDED
